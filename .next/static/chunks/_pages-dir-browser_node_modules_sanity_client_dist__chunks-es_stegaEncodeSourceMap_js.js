"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_sanity_client_dist__chunks-es_stegaEncodeSourceMap_js"],{

/***/ "(pages-dir-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   stegaEncodeSourceMap: () => (/* binding */ stegaEncodeSourceMap),\n/* harmony export */   stegaEncodeSourceMap$1: () => (/* binding */ stegaEncodeSourceMap$1)\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(pages-dir-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if ((0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.isRecord)(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if ((0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.isRecord)(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_FOLDER = \"drafts\", VERSION_FOLDER = \"versions\", PATH_SEPARATOR = \".\", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;\nfunction isDraftId(id) {\n  return id.startsWith(DRAFTS_PREFIX);\n}\nfunction isVersionId(id) {\n  return id.startsWith(VERSION_PREFIX);\n}\nfunction isPublishedId(id) {\n  return !isDraftId(id) && !isVersionId(id);\n}\nfunction getVersionFromId(id) {\n  if (!isVersionId(id)) return;\n  const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);\n  return versionId;\n}\nfunction getPublishedId(id) {\n  return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), isPublishedId(_id))\n    searchParams.set(\"perspective\", \"published\");\n  else if (isVersionId(_id)) {\n    const versionId = getVersionFromId(_id);\n    searchParams.set(\"perspective\", versionId);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"textTheme\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl) return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsUUFBUTtBQUNsQztBQUNBLGdCQUFnQixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsUUFBUTtBQUN0RDtBQUNBLGdCQUFnQixPQUFPLFVBQVUsYUFBYTtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sR0FBRyxLQUFLLEdBQUcsR0FBRztBQUNyQztBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBd0QsNERBQTRELHVDQUF1QyxRQUFRLDBDQUEwQyx5REFBeUQsV0FBVyxlQUFlLGFBQWE7QUFDMVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLENBQUM7QUFLQztBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXExlbm92b1xcRG9jdW1lbnRzXFxDb2Rlc1xcTmV4dFdvcmtzXFxPQ0VQb3dlckhvdXNlXFxub2RlX21vZHVsZXNcXEBzYW5pdHlcXGNsaWVudFxcZGlzdFxcX2NodW5rcy1lc1xcc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNSZWNvcmQsIEMgfSBmcm9tIFwiLi9zdGVnYUNsZWFuLmpzXCI7XG5jb25zdCByZUtleVNlZ21lbnQgPSAvX2tleVxccyo9PVxccypbJ1wiXSguKilbJ1wiXS87XG5mdW5jdGlvbiBpc0tleVNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IHJlS2V5U2VnbWVudC50ZXN0KHNlZ21lbnQudHJpbSgpKSA6IHR5cGVvZiBzZWdtZW50ID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHBhdGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGFuIGFycmF5XCIpO1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHRhcmdldCwgc2VnbWVudCwgaSkgPT4ge1xuICAgIGNvbnN0IHNlZ21lbnRUeXBlID0gdHlwZW9mIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnRUeXBlID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtzZWdtZW50fV1gO1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9JHtpID09PSAwID8gXCJcIiA6IFwiLlwifSR7c2VnbWVudH1gO1xuICAgIGlmIChpc0tleVNlZ21lbnQoc2VnbWVudCkgJiYgc2VnbWVudC5fa2V5KVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bX2tleT09XCIke3NlZ21lbnQuX2tleX1cIl1gO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICBjb25zdCBbZnJvbSwgdG9dID0gc2VnbWVudDtcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7ZnJvbX06JHt0b31dYDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXRoIHNlZ21lbnQgXFxgJHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1cXGBgKTtcbiAgfSwgXCJcIik7XG59XG5jb25zdCBFU0NBUEUgPSB7XG4gIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgXCJcXG5cIjogXCJcXFxcblwiLFxuICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gIFwiXHRcIjogXCJcXFxcdFwiLFxuICBcIidcIjogXCJcXFxcJ1wiLFxuICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG59LCBVTkVTQ0FQRSA9IHtcbiAgXCJcXFxcZlwiOiBcIlxcZlwiLFxuICBcIlxcXFxuXCI6IGBcbmAsXG4gIFwiXFxcXHJcIjogXCJcXHJcIixcbiAgXCJcXFxcdFwiOiBcIlx0XCIsXG4gIFwiXFxcXCdcIjogXCInXCIsXG4gIFwiXFxcXFxcXFxcIjogXCJcXFxcXCJcbn07XG5mdW5jdGlvbiBqc29uUGF0aChwYXRoKSB7XG4gIHJldHVybiBgJCR7cGF0aC5tYXAoKHNlZ21lbnQpID0+IHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyBgWycke3NlZ21lbnQucmVwbGFjZSgvW1xcZlxcblxcclxcdCdcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfSddYCA6IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIgPyBgWyR7c2VnbWVudH1dYCA6IHNlZ21lbnQuX2tleSAhPT0gXCJcIiA/IGBbPyhALl9rZXk9PScke3NlZ21lbnQuX2tleS5yZXBsYWNlKC9bJ1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9JyldYCA6IGBbJHtzZWdtZW50Ll9pbmRleH1dYCkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VKc29uUGF0aChwYXRoKSB7XG4gIGNvbnN0IHBhcnNlZCA9IFtdLCBwYXJzZVJlID0gL1xcWycoLio/KSdcXF18XFxbKFxcZCspXFxdfFxcW1xcP1xcKEBcXC5fa2V5PT0nKC4qPyknXFwpXFxdL2c7XG4gIGxldCBtYXRjaDtcbiAgZm9yICg7IChtYXRjaCA9IHBhcnNlUmUuZXhlYyhwYXRoKSkgIT09IG51bGw7ICkge1xuICAgIGlmIChtYXRjaFsxXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBrZXkgPSBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcKFxcXFx8ZnxufHJ8dHwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goa2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzNdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IF9rZXkgPSBtYXRjaFszXS5yZXBsYWNlKC9cXFxcKFxcXFwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICBfa2V5LFxuICAgICAgICBfaW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2tleSAhPT0gXCJcIilcbiAgICAgIHJldHVybiB7IF9rZXk6IHNlZ21lbnQuX2tleSB9O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBqc29uUGF0aFRvTWFwcGluZ1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2luZGV4ICE9PSAtMSlcbiAgICAgIHJldHVybiBzZWdtZW50Ll9pbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VnbWVudDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVNYXBwaW5nKHJlc3VsdFBhdGgsIGNzbSkge1xuICBpZiAoIWNzbT8ubWFwcGluZ3MpXG4gICAgcmV0dXJuO1xuICBjb25zdCByZXN1bHRNYXBwaW5nUGF0aCA9IGpzb25QYXRoKGpzb25QYXRoVG9NYXBwaW5nUGF0aChyZXN1bHRQYXRoKSk7XG4gIGlmIChjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcHBpbmc6IGNzbS5tYXBwaW5nc1tyZXN1bHRNYXBwaW5nUGF0aF0sXG4gICAgICBtYXRjaGVkUGF0aDogcmVzdWx0TWFwcGluZ1BhdGgsXG4gICAgICBwYXRoU3VmZml4OiBcIlwiXG4gICAgfTtcbiAgY29uc3QgbWFwcGluZ3MgPSBPYmplY3QuZW50cmllcyhjc20ubWFwcGluZ3MpLmZpbHRlcigoW2tleV0pID0+IHJlc3VsdE1hcHBpbmdQYXRoLnN0YXJ0c1dpdGgoa2V5KSkuc29ydCgoW2tleTFdLCBba2V5Ml0pID0+IGtleTIubGVuZ3RoIC0ga2V5MS5sZW5ndGgpO1xuICBpZiAobWFwcGluZ3MubGVuZ3RoID09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCBbbWF0Y2hlZFBhdGgsIG1hcHBpbmddID0gbWFwcGluZ3NbMF0sIHBhdGhTdWZmaXggPSByZXN1bHRNYXBwaW5nUGF0aC5zdWJzdHJpbmcobWF0Y2hlZFBhdGgubGVuZ3RoKTtcbiAgcmV0dXJuIHsgbWFwcGluZywgbWF0Y2hlZFBhdGgsIHBhdGhTdWZmaXggfTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gd2Fsa01hcCh2YWx1ZSwgbWFwcGluZ0ZuLCBwYXRoID0gW10pIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZS5tYXAoKHYsIGlkeCkgPT4ge1xuICAgICAgaWYgKGlzUmVjb3JkKHYpKSB7XG4gICAgICAgIGNvbnN0IF9rZXkgPSB2Ll9rZXk7XG4gICAgICAgIGlmICh0eXBlb2YgX2tleSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoeyBfa2V5LCBfaW5kZXg6IGlkeCB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGlkeCkpO1xuICAgIH0pO1xuICBpZiAoaXNSZWNvcmQodmFsdWUpKSB7XG4gICAgaWYgKHZhbHVlLl90eXBlID09PSBcImJsb2NrXCIgfHwgdmFsdWUuX3R5cGUgPT09IFwic3BhblwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7IC4uLnZhbHVlIH07XG4gICAgICByZXR1cm4gdmFsdWUuX3R5cGUgPT09IFwiYmxvY2tcIiA/IHJlc3VsdC5jaGlsZHJlbiA9IHdhbGtNYXAodmFsdWUuY2hpbGRyZW4sIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoXCJjaGlsZHJlblwiKSkgOiB2YWx1ZS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgKHJlc3VsdC50ZXh0ID0gd2Fsa01hcCh2YWx1ZS50ZXh0LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KFwidGV4dFwiKSkpLCByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbaywgdl0pID0+IFtrLCB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaykpXSlcbiAgICApO1xuICB9XG4gIHJldHVybiBtYXBwaW5nRm4odmFsdWUsIHBhdGgpO1xufVxuZnVuY3Rpb24gZW5jb2RlSW50b1Jlc3VsdChyZXN1bHQsIGNzbSwgZW5jb2Rlcikge1xuICByZXR1cm4gd2Fsa01hcChyZXN1bHQsICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCByZXNvbHZlTWFwcGluZ1Jlc3VsdCA9IHJlc29sdmVNYXBwaW5nKHBhdGgsIGNzbSk7XG4gICAgaWYgKCFyZXNvbHZlTWFwcGluZ1Jlc3VsdClcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoIH0gPSByZXNvbHZlTWFwcGluZ1Jlc3VsdDtcbiAgICBpZiAobWFwcGluZy50eXBlICE9PSBcInZhbHVlXCIgfHwgbWFwcGluZy5zb3VyY2UudHlwZSAhPT0gXCJkb2N1bWVudFZhbHVlXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc291cmNlRG9jdW1lbnQgPSBjc20uZG9jdW1lbnRzW21hcHBpbmcuc291cmNlLmRvY3VtZW50XSwgc291cmNlUGF0aCA9IGNzbS5wYXRoc1ttYXBwaW5nLnNvdXJjZS5wYXRoXSwgbWF0Y2hQYXRoU2VnbWVudHMgPSBwYXJzZUpzb25QYXRoKG1hdGNoZWRQYXRoKSwgZnVsbFNvdXJjZVNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChzb3VyY2VQYXRoKS5jb25jYXQocGF0aC5zbGljZShtYXRjaFBhdGhTZWdtZW50cy5sZW5ndGgpKTtcbiAgICByZXR1cm4gZW5jb2Rlcih7XG4gICAgICBzb3VyY2VQYXRoOiBmdWxsU291cmNlU2VnbWVudHMsXG4gICAgICBzb3VyY2VEb2N1bWVudCxcbiAgICAgIHJlc3VsdFBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IERSQUZUU19GT0xERVIgPSBcImRyYWZ0c1wiLCBWRVJTSU9OX0ZPTERFUiA9IFwidmVyc2lvbnNcIiwgUEFUSF9TRVBBUkFUT1IgPSBcIi5cIiwgRFJBRlRTX1BSRUZJWCA9IGAke0RSQUZUU19GT0xERVJ9JHtQQVRIX1NFUEFSQVRPUn1gLCBWRVJTSU9OX1BSRUZJWCA9IGAke1ZFUlNJT05fRk9MREVSfSR7UEFUSF9TRVBBUkFUT1J9YDtcbmZ1bmN0aW9uIGlzRHJhZnRJZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChEUkFGVFNfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGlzVmVyc2lvbklkKGlkKSB7XG4gIHJldHVybiBpZC5zdGFydHNXaXRoKFZFUlNJT05fUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGlzUHVibGlzaGVkSWQoaWQpIHtcbiAgcmV0dXJuICFpc0RyYWZ0SWQoaWQpICYmICFpc1ZlcnNpb25JZChpZCk7XG59XG5mdW5jdGlvbiBnZXRWZXJzaW9uRnJvbUlkKGlkKSB7XG4gIGlmICghaXNWZXJzaW9uSWQoaWQpKSByZXR1cm47XG4gIGNvbnN0IFtfdmVyc2lvblByZWZpeCwgdmVyc2lvbklkLCAuLi5fcHVibGlzaGVkSWRdID0gaWQuc3BsaXQoUEFUSF9TRVBBUkFUT1IpO1xuICByZXR1cm4gdmVyc2lvbklkO1xufVxuZnVuY3Rpb24gZ2V0UHVibGlzaGVkSWQoaWQpIHtcbiAgcmV0dXJuIGlzVmVyc2lvbklkKGlkKSA/IGlkLnNwbGl0KFBBVEhfU0VQQVJBVE9SKS5zbGljZSgyKS5qb2luKFBBVEhfU0VQQVJBVE9SKSA6IGlzRHJhZnRJZChpZCkgPyBpZC5zbGljZShEUkFGVFNfUFJFRklYLmxlbmd0aCkgOiBpZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRVcmwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICB3b3Jrc3BhY2U6IF93b3Jrc3BhY2UgPSBcImRlZmF1bHRcIixcbiAgICB0b29sOiBfdG9vbCA9IFwiZGVmYXVsdFwiLFxuICAgIGlkOiBfaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoLFxuICAgIHByb2plY3RJZCxcbiAgICBkYXRhc2V0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWJhc2VVcmwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFwYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGggaXMgcmVxdWlyZWRcIik7XG4gIGlmICghX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoYmFzZVVybCAhPT0gXCIvXCIgJiYgYmFzZVVybC5lbmRzV2l0aChcIi9cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBtdXN0IG5vdCBlbmQgd2l0aCBhIHNsYXNoXCIpO1xuICBjb25zdCB3b3Jrc3BhY2UgPSBfd29ya3NwYWNlID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF93b3Jrc3BhY2UsIHRvb2wgPSBfdG9vbCA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfdG9vbCwgaWQgPSBnZXRQdWJsaXNoZWRJZChfaWQpLCBzdHJpbmdpZmllZFBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpIDogcGF0aCwgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgYmFzZVVybCxcbiAgICBpZCxcbiAgICB0eXBlLFxuICAgIHBhdGg6IHN0cmluZ2lmaWVkUGF0aFxuICB9KTtcbiAgaWYgKHdvcmtzcGFjZSAmJiBzZWFyY2hQYXJhbXMuc2V0KFwid29ya3NwYWNlXCIsIHdvcmtzcGFjZSksIHRvb2wgJiYgc2VhcmNoUGFyYW1zLnNldChcInRvb2xcIiwgdG9vbCksIHByb2plY3RJZCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwicHJvamVjdElkXCIsIHByb2plY3RJZCksIGRhdGFzZXQgJiYgc2VhcmNoUGFyYW1zLnNldChcImRhdGFzZXRcIiwgZGF0YXNldCksIGlzUHVibGlzaGVkSWQoX2lkKSlcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwicGVyc3BlY3RpdmVcIiwgXCJwdWJsaXNoZWRcIik7XG4gIGVsc2UgaWYgKGlzVmVyc2lvbklkKF9pZCkpIHtcbiAgICBjb25zdCB2ZXJzaW9uSWQgPSBnZXRWZXJzaW9uRnJvbUlkKF9pZCk7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcInBlcnNwZWN0aXZlXCIsIHZlcnNpb25JZCk7XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBbYmFzZVVybCA9PT0gXCIvXCIgPyBcIlwiIDogYmFzZVVybF07XG4gIHdvcmtzcGFjZSAmJiBzZWdtZW50cy5wdXNoKHdvcmtzcGFjZSk7XG4gIGNvbnN0IHJvdXRlclBhcmFtcyA9IFtcbiAgICBcIm1vZGU9cHJlc2VudGF0aW9uXCIsXG4gICAgYGlkPSR7aWR9YCxcbiAgICBgdHlwZT0ke3R5cGV9YCxcbiAgICBgcGF0aD0ke2VuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZmllZFBhdGgpfWBcbiAgXTtcbiAgcmV0dXJuIHRvb2wgJiYgcm91dGVyUGFyYW1zLnB1c2goYHRvb2w9JHt0b29sfWApLCBzZWdtZW50cy5wdXNoKFwiaW50ZW50XCIsIFwiZWRpdFwiLCBgJHtyb3V0ZXJQYXJhbXMuam9pbihcIjtcIil9PyR7c2VhcmNoUGFyYW1zfWApLCBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTdHVkaW9CYXNlUm91dGUoc3R1ZGlvVXJsKSB7XG4gIGxldCBiYXNlVXJsID0gdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8gc3R1ZGlvVXJsIDogc3R1ZGlvVXJsLmJhc2VVcmw7XG4gIHJldHVybiBiYXNlVXJsICE9PSBcIi9cIiAmJiAoYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpKSwgdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8geyBiYXNlVXJsIH0gOiB7IC4uLnN0dWRpb1VybCwgYmFzZVVybCB9O1xufVxuY29uc3QgZmlsdGVyRGVmYXVsdCA9ICh7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgaWYgKGlzVmFsaWREYXRlKHZhbHVlKSB8fCBpc1ZhbGlkVVJMKHZhbHVlKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGVuZFBhdGggPSBzb3VyY2VQYXRoLmF0KC0xKTtcbiAgcmV0dXJuICEoc291cmNlUGF0aC5hdCgtMikgPT09IFwic2x1Z1wiICYmIGVuZFBhdGggPT09IFwiY3VycmVudFwiIHx8IHR5cGVvZiBlbmRQYXRoID09IFwic3RyaW5nXCIgJiYgKGVuZFBhdGguc3RhcnRzV2l0aChcIl9cIikgfHwgZW5kUGF0aC5lbmRzV2l0aChcIklkXCIpKSB8fCBzb3VyY2VQYXRoLnNvbWUoXG4gICAgKHBhdGgpID0+IHBhdGggPT09IFwibWV0YVwiIHx8IHBhdGggPT09IFwibWV0YWRhdGFcIiB8fCBwYXRoID09PSBcIm9wZW5HcmFwaFwiIHx8IHBhdGggPT09IFwic2VvXCJcbiAgKSB8fCBoYXNUeXBlTGlrZShzb3VyY2VQYXRoKSB8fCBoYXNUeXBlTGlrZShyZXN1bHRQYXRoKSB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIGRlbnlsaXN0LmhhcyhlbmRQYXRoKSk7XG59LCBkZW55bGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjb2xvclwiLFxuICBcImNvbG91clwiLFxuICBcImN1cnJlbmN5XCIsXG4gIFwiZW1haWxcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJnaWRcIixcbiAgXCJoZXhcIixcbiAgXCJocmVmXCIsXG4gIFwiaHNsXCIsXG4gIFwiaHNsYVwiLFxuICBcImljb25cIixcbiAgXCJpZFwiLFxuICBcImluZGV4XCIsXG4gIFwia2V5XCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJsYXlvdXRcIixcbiAgXCJsaW5rXCIsXG4gIFwibGlua0FjdGlvblwiLFxuICBcImxvY2FsZVwiLFxuICBcImxxaXBcIixcbiAgXCJwYWdlXCIsXG4gIFwicGF0aFwiLFxuICBcInJlZlwiLFxuICBcInJnYlwiLFxuICBcInJnYmFcIixcbiAgXCJyb3V0ZVwiLFxuICBcInNlY3JldFwiLFxuICBcInNsdWdcIixcbiAgXCJzdGF0dXNcIixcbiAgXCJ0YWdcIixcbiAgXCJ0ZW1wbGF0ZVwiLFxuICBcInRoZW1lXCIsXG4gIFwidHlwZVwiLFxuICBcInRleHRUaGVtZVwiLFxuICBcInVuaXRcIixcbiAgXCJ1cmxcIixcbiAgXCJ1c2VybmFtZVwiLFxuICBcInZhcmlhbnRcIixcbiAgXCJ3ZWJzaXRlXCJcbl0pO1xuZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZVN0cmluZykge1xuICByZXR1cm4gL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyaW5nKSA/ICEhRGF0ZS5wYXJzZShkYXRlU3RyaW5nKSA6ICExO1xufVxuZnVuY3Rpb24gaXNWYWxpZFVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHVybCwgdXJsLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gaGFzVHlwZUxpa2UocGF0aCkge1xuICByZXR1cm4gcGF0aC5zb21lKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmIHNlZ21lbnQubWF0Y2goL3R5cGUvaSkgIT09IG51bGwpO1xufVxuY29uc3QgVFJVTkNBVEVfTEVOR1RIID0gMjA7XG5mdW5jdGlvbiBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnKSB7XG4gIGNvbnN0IHsgZmlsdGVyLCBsb2dnZXIsIGVuYWJsZWQgfSA9IGNvbmZpZztcbiAgaWYgKCFlbmFibGVkKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuZW5hYmxlZCBtdXN0IGJlIHRydWUsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvdGhlcndpc2VcIjtcbiAgICB0aHJvdyBsb2dnZXI/LmVycm9yPy4oYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGlmICghcmVzdWx0U291cmNlTWFwKVxuICAgIHJldHVybiBsb2dnZXI/LmVycm9yPy4oXCJbQHNhbml0eS9jbGllbnRdOiBNaXNzaW5nIENvbnRlbnQgU291cmNlIE1hcCBmcm9tIHJlc3BvbnNlIGJvZHlcIiwge1xuICAgICAgcmVzdWx0LFxuICAgICAgcmVzdWx0U291cmNlTWFwLFxuICAgICAgY29uZmlnXG4gICAgfSksIHJlc3VsdDtcbiAgaWYgKCFjb25maWcuc3R1ZGlvVXJsKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuc3R1ZGlvVXJsIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIHRocm93IGxvZ2dlcj8uZXJyb3I/LihgW0BzYW5pdHkvY2xpZW50XTogJHttc2d9YCwgeyByZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnIH0pLCBuZXcgVHlwZUVycm9yKG1zZyk7XG4gIH1cbiAgY29uc3QgcmVwb3J0ID0ge1xuICAgIGVuY29kZWQ6IFtdLFxuICAgIHNraXBwZWQ6IFtdXG4gIH0sIHJlc3VsdFdpdGhTdGVnYSA9IGVuY29kZUludG9SZXN1bHQoXG4gICAgcmVzdWx0LFxuICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAoeyBzb3VyY2VQYXRoLCBzb3VyY2VEb2N1bWVudCwgcmVzdWx0UGF0aCwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKCh0eXBlb2YgZmlsdGVyID09IFwiZnVuY3Rpb25cIiA/IGZpbHRlcih7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIGZpbHRlckRlZmF1bHQsIHNvdXJjZURvY3VtZW50LCB2YWx1ZSB9KSA6IGZpbHRlckRlZmF1bHQoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSkgPT09ICExKVxuICAgICAgICByZXR1cm4gbG9nZ2VyICYmIHJlcG9ydC5za2lwcGVkLnB1c2goe1xuICAgICAgICAgIHBhdGg6IHByZXR0eVBhdGhGb3JMb2dnaW5nKHNvdXJjZVBhdGgpLFxuICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aFxuICAgICAgICB9KSwgdmFsdWU7XG4gICAgICBsb2dnZXIgJiYgcmVwb3J0LmVuY29kZWQucHVzaCh7XG4gICAgICAgIHBhdGg6IHByZXR0eVBhdGhGb3JMb2dnaW5nKHNvdXJjZVBhdGgpLFxuICAgICAgICB2YWx1ZTogYCR7dmFsdWUuc2xpY2UoMCwgVFJVTkNBVEVfTEVOR1RIKX0ke3ZhbHVlLmxlbmd0aCA+IFRSVU5DQVRFX0xFTkdUSCA/IFwiLi4uXCIgOiBcIlwifWAsXG4gICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgYmFzZVVybCwgd29ya3NwYWNlLCB0b29sIH0gPSByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKFxuICAgICAgICB0eXBlb2YgY29uZmlnLnN0dWRpb1VybCA9PSBcImZ1bmN0aW9uXCIgPyBjb25maWcuc3R1ZGlvVXJsKHNvdXJjZURvY3VtZW50KSA6IGNvbmZpZy5zdHVkaW9VcmxcbiAgICAgICk7XG4gICAgICBpZiAoIWJhc2VVcmwpIHJldHVybiB2YWx1ZTtcbiAgICAgIGNvbnN0IHsgX2lkOiBpZCwgX3R5cGU6IHR5cGUsIF9wcm9qZWN0SWQ6IHByb2plY3RJZCwgX2RhdGFzZXQ6IGRhdGFzZXQgfSA9IHNvdXJjZURvY3VtZW50O1xuICAgICAgcmV0dXJuIEMoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luOiBcInNhbml0eS5pb1wiLFxuICAgICAgICAgIGhyZWY6IGNyZWF0ZUVkaXRVcmwoe1xuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgICAgIHRvb2wsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoOiBzb3VyY2VQYXRoLFxuICAgICAgICAgICAgLi4uIWNvbmZpZy5vbWl0Q3Jvc3NEYXRhc2V0UmVmZXJlbmNlRGF0YSAmJiB7IGRhdGFzZXQsIHByb2plY3RJZCB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2UgdXNlIGN1c3RvbSBsb2dpYyB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHNraXAgZW5jb2RpbmdcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgfVxuICApO1xuICBpZiAobG9nZ2VyKSB7XG4gICAgY29uc3QgaXNTa2lwcGluZyA9IHJlcG9ydC5za2lwcGVkLmxlbmd0aCwgaXNFbmNvZGluZyA9IHJlcG9ydC5lbmNvZGVkLmxlbmd0aDtcbiAgICBpZiAoKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgKChsb2dnZXI/Lmdyb3VwQ29sbGFwc2VkIHx8IGxvZ2dlci5sb2cpPy4oXCJbQHNhbml0eS9jbGllbnRdOiBFbmNvZGluZyBzb3VyY2UgbWFwIGludG8gcmVzdWx0XCIpLCBsb2dnZXIubG9nPy4oXG4gICAgICBgW0BzYW5pdHkvY2xpZW50XTogUGF0aHMgZW5jb2RlZDogJHtyZXBvcnQuZW5jb2RlZC5sZW5ndGh9LCBza2lwcGVkOiAke3JlcG9ydC5za2lwcGVkLmxlbmd0aH1gXG4gICAgKSksIHJlcG9ydC5lbmNvZGVkLmxlbmd0aCA+IDAgJiYgKGxvZ2dlcj8ubG9nPy4oXCJbQHNhbml0eS9jbGllbnRdOiBUYWJsZSBvZiBlbmNvZGVkIHBhdGhzXCIpLCAobG9nZ2VyPy50YWJsZSB8fCBsb2dnZXIubG9nKT8uKHJlcG9ydC5lbmNvZGVkKSksIHJlcG9ydC5za2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNraXBwZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCB7IHBhdGggfSBvZiByZXBvcnQuc2tpcHBlZClcbiAgICAgICAgc2tpcHBlZC5hZGQocGF0aC5yZXBsYWNlKHJlS2V5U2VnbWVudCwgXCIwXCIpLnJlcGxhY2UoL1xcW1xcZCtcXF0vZywgXCJbXVwiKSk7XG4gICAgICBsb2dnZXI/LmxvZz8uKFwiW0BzYW5pdHkvY2xpZW50XTogTGlzdCBvZiBza2lwcGVkIHBhdGhzXCIsIFsuLi5za2lwcGVkLnZhbHVlcygpXSk7XG4gICAgfVxuICAgIChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpICYmIGxvZ2dlcj8uZ3JvdXBFbmQ/LigpO1xuICB9XG4gIHJldHVybiByZXN1bHRXaXRoU3RlZ2E7XG59XG5mdW5jdGlvbiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhwYXRoKSB7XG4gIHJldHVybiB0b1N0cmluZyhqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSk7XG59XG52YXIgc3RlZ2FFbmNvZGVTb3VyY2VNYXAkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcFxufSk7XG5leHBvcnQge1xuICBlbmNvZGVJbnRvUmVzdWx0LFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXAkMVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZWdhRW5jb2RlU291cmNlTWFwLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n"));

/***/ })

}]);